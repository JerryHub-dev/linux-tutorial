# 善用判断

在 [第十章](../10/05.md#指令回传值-与-和) 中，提到过 `$?` 这个变量所代表的含义，以及通过 `&& 和 ||` 来判定前一个指令执行回传值对于后一个指令是否要进行的依据。

在第十章中，判定一个目录是否存在，使用了 `ll 目录 && 执行指令` 的方式来判定 xx 目录是否存在，从而决定后续指令是否执行，但是有更简单的方式进行条件判断，就是通过 test 指令

## 使用 test 指令的测试功能

test 指令主要用于检测文件或相关属性时的指令和比较值，比如检查 /mrcode 是否存在时

```bash
# -e 是检测文件是否存在的选项
[root@cloud-08 script]# test -e /mrcode
```

上面命令没有任何输出值

```bash
[root@cloud-08 script]# test -e /mrcode && echo "exist" || "not exist"
exist
# 通过与 && 或 || 可以知道是存在还是不存在了
```

要善用 man 查看该指令的信息，下面是整理翻译出来的其他选项

关于某个文件名的 **文件类型** 判断。如  `test -e filename`  标识是否存在

| 测试的标志 | 含义 |
| :--------: | :--- |
| -e | 文件是否存在；**常用** |
| -f | 该文件是否存在且为文件（file）？**常用** |
| -d | 该文件是否存在且为目录（directory）？**常用** |
| -b | 该文件是否存在且为一个 block device 装置？ |
| -c | 该文件是否存在且为一个 character device 装置？ |
| -S | 该文件是否存在且为一个 Socket 文件？ |
| -p | 该文件是否存在且为一个 FIFO（pipe）文件？ |
| -L | 该文件是否存在且为一个连接文件？ |

关于文件的 **权限** 判定。如 `test -r filename` 标识是否可读？（但 root 权限常有例外）

| 测试的标志 | 含义 |
| :--------: | :--- |
| -r | 该文件是否存在且具有可读权限？ |
| -w | 该文件是否存在且具有可写权限？ |
| -x | 该文件是否存在且具有可执行权限？ |
| -u | 该文件是否存在且具有 SUID 属性？ |
| -g | 该文件是否存在且具有 SGID 属性？ |
| -k | 该文件是否存在且具有 Sticky bit 属性？ |
| -s | 该文件是否存在且为「非空白文件」？ |

两个文件之间的比较。如 `test file1 -nt file2`

| 测试的标志 | 含义 |
| :--------: | :--- |
| -nt | （newer than）判断 file1 是否比 file2 新 |
| -ot | （older than）判断 file1  是否比 file2 旧 |
| -ef | 判断 file1 与 file2 是否是同一文件，可用在判断 hard link 的判定上。主要意义在判定两个文件是否均指向同一个 inode |

两个整数之间的判定。`test nl -eq n2`

| 测试的标志 | 含义 |
| :--------: | :--- |
| -eq | 两数值相等（equal） |
| -ne | 不相等（not equal） |
| -gt | 大于（greater than） |
| -lt | 小于（less than） |
| -ge | 大于等于（greater than or equal） |
| -le | 小于等于（less than or equal） |

判定字符串的数据

| 测试的标志 | 含义 |
| :--------: | :--- |
| test -z string | 判定字符串是否为 0？若为空串，则为 true |
| test -n string | 判定字符串是否不为 0？若为空串，则为 false；注意：-n 可省略 |
| test str1 == str2 | 是否相等，相等则为 true |
| test str1 !=  str2 | 是否不相等，相等则为 false |

多重条件判断。比如 `test -r filename -a -x filename`

| 测试的标志 | 含义 |
| :--------: | :--- |
| -a | （and）两状况同时成立；如：`test -r filename -a -x filename`，则 file 同时具有 r 与 x 权限时才为 true |
| -o | （or）任意一个成立。如：`test -r filename -o -x filename`，则 file 具有 r 或 x 权限时就为 true |
| ! | 反向状态。 |

总结完这么多的判定，就可以来写几个简单的例子。让用户输入一个文件名，我们判断：

1. 该文件是否存在，若不存在则给予一个「Filename does not exist」 提示，并中断程序
2. 若该文件存在，则判断是文件还是目录：文件输出「Filename is regular file」，目录输出 「Filename is directory」
3. 判断执行者的身份对这个文件或目录所拥有的权限，并输出权限数据

下面是笔者写的思路，代码组织方面有点糟糕。还有指令使用不太熟悉

```bash
#!/bin/bash
# Program
# 
# History
#       2020/01/19              mrcode          first relese
read -p "请输入一个文件名：" filename
# 判断是否输入了字符串
test -z ${filename} && echo "请输入一个有效的文件名！" && exit -1

# 判断该文件是否存在: 不存在输出提示信息并退出
# 特别是这里的多条指令的执行，使用 || 会很难处理，只能转成 true
test ! -e ${filename} && echo "${filename} does not exist" && exit -1

# 提示是文件还是目录
test -f ${filename} && echo "${filename} is regular file" || echo "${filename} is directory"

# 判断执行者的身份对这个文件拥有的权限，并输出
test -r ${filename} && echo "${filename} 可读"
test -w ${filename} && echo "${filename} 可写"
test -x ${filename} && echo "${filename} 可执行"
```

测试输出如下

```bash
[mrcode@study bin]$ ./file_perm.sh 
请输入一个文件名：ss
ss does not exist
[mrcode@study bin]$ ./file_perm.sh 
请输入一个文件名：/etc
/etc is directory
/etc 可读
/etc 可执行
```



书上代码如下

```bash
vim file_perm.sh
#!/bin/bash
# Program
#   User input a filename,program will check the flowing:
#	1.) exist?
#	2.) file/directory?
#	3.) file permissions
# History
#       2020/01/19              mrcode          first relese
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

echo -e "Please input a filename,I will check the filename's type and permission. \n\n"
read -p "Input a filename ：" filename
# 判断是否输入了字符串
test -z ${filename} && echo "You MUST input a filename. " && exit 0

# 判断该文件是否存在: 不存在输出提示信息并退出
test ! -e ${filename} && echo "The filename ${filename} does not exist" && exit 0

# 开始判断文件类型与属性
test -f ${filename} && filetype="regulare file"
test -d ${filename} && filetype="directory"
test -r ${filename} && perm="readable"
test -w ${filename} && perm="${perm} writable"
test -x ${filename} && perm="${perm} executable"

# 信息输出
echo "The filename: ${filename} is a ${filetype}"
echo "And the permissions for you are : ${perm}"
```

测试输出如下

```bash
[mrcode@study bin]$ ./file_perm.sh 
Please input a filename,I will check the filename's type and permission. 


Input a filename ：ss
The filename ss does not exist
[mrcode@study bin]$ ./file_perm.sh 
Please input a filename,I will check the filename's type and permission. 


Input a filename ：/etc
The filename: /etc is a directory
And the permissions for you are : readable executable
```

自己写的脚本组织来看，除了不熟悉指令用法之外，对于程序结构的抽象不够好，对比书上的，发觉这个代码组织的不错

另外，该脚本检查权限的指令是针对运行该脚本的用户所反馈的，所以当使用 root 的时候，常常会发现与 ls -l 观察到的结果并不相同
