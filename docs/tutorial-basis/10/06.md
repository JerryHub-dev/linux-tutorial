# 管线命令（pipe）

bash 命令执行的时候有输出数据，如果这群数据必须经过几道手续之后才能得到我们想要的格式，这就可以使用管线命令（pipe）来完成了

假设我们想知道 `/etc/` 下有多少文件，可以使用 `ls /etc/` 来查询，不过因为文件太多了，输出占满整个屏幕，导致最开始是什么文件看不到了，这就可以通过管线命令结合 less 指令来达成

```bash
[mrcode@study ~]$ ls -al | less
```

如此一来， `ls -al` 指令输出后的内容，能够被 less 读取，并且利用 less 的功能，可以前后翻动相关信息

管线命令**仅能处理**由前一个指令传来的**正确信息**（standard output），对于 standard error 没有直接处理的能力，整体管线命令可以使用下图表示

![image-20191204232521041](./assets/image-20191204232521041.png)

在每个管线后面接的第一个数据必定是「指令」，而且这个指令必须能接受 standard input 的数据才可以，这样的指令则是「管线命令」，例如 less、more、head、tail 等都是可以接受 standard input 的管线命令。而 ls、cp、mv 等就不是管线命令了，因为他们不不会接受来自 stdin 的数据。管线命令主要有两个比较需要注意的地方：

- 管线命令仅会处理 standard output ，对于 standard error output 会忽略
- 管线命令必须要能接受来自前一个指令的数据成为 standard input 继续处理才行

如果硬要 standard error 可以被管线命令所使用可以使用如下方式

```bash
2>&1   让标准错误输出转成标准输出
```

那么下面来玩一些管线命令，以下知识点对系统管理费用有用

## 截取命令 cut、grep

简单说：将一段时间经过分析后，取出我们想要的。或则是经过由分析关键词，取得我们所想要的那一行。一般来说，截取信息通常是针对一行一行来分析的。

### cut

```bash
cut -d '分割字符' -f fields  # 用于有特定分割字符
cut -c 字符区间							 # 用于排列整齐的信息
```

选项与参数：

- d：后面接分割字符。与 `-f` 一起使用
- f：依据 -d 的分割字符将一段信息分区成数段，用 -f 取出第几段的意思
- c：以字符（characters）的单位取出固定字符区间

```bash
# 范例 1：将 PATH 变量取出，我要找出第 5 个路径
[mrcode@study ~]$ echo ${PATH}
/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/mrcode/.local/bin:/home/mrcode/bin
# 数量是从 1 开始，不是从 0 哟
[mrcode@study ~]$ echo ${PATH} | cut -d ':' -f 5
/usr/sbin

# 取出第 5 个和第 6 个
[mrcode@study ~]$ echo ${PATH} | cut -d ':' -f 5,6
/usr/sbin:/home/mrcode/.local/bin


# 范例 2 ：将 export 输出的信息，取得第 12 字符以后的所有字符串
[mrcode@study ~]$ export
declare -x HISTCONTROL="ignoredups"
declare -x HISTSIZE="1000"
declare -x HOME="/home/mrcode"
declare -x HOSTNAME="study.centos.mrcode"
...

# 以上数据每个都是排列整齐的，有着 declare -x 前缀
# 那么想要把前缀去掉，就可以这样做
[mrcode@study ~]$ export | cut -c 12-
HISTCONTROL="ignoredups"
HISTSIZE="1000"
HOME="/home/mrcode"
# 使用 12-15 则是截取出这个区间的字符
# 使用 12 则只截取 12 这个字符

# 范例 3 ：用 last 将显示的登陆者信息，仅留下用户名
[mrcode@study ~]$ last
# 账户 		终端机					登录 IP					日期时间						
mrcode   pts/1        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/0        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/1        192.168.0.105    Mon Dec  2 00:21 - 01:12  (00:51)  
# 用空格分隔的数据，那么可以这样做
[mrcode@study ~]$ last | cut -d ' ' -f 1
mrcode
mrcode
mrcode
# 其实 账户和终端机之间的空格有好几个，并不是一个所以使用下面的命令并不能把 终端机一列也提取出来
last | cut -d ' ' -f 1,2
```

cut 主要的用途：将同一行里面的数据进行分解

常使用在分析一些数据或文字数据的时候，因为有时候会以某些字符当做分区的参数，然后将数据切割，以取得我们所需要的数据，作者常常在分析 log 文件的时候，但是 cut 在处理多空格相连的数据时，就比较麻烦，所以某些常见可能需要使用下一章节要讲解的 awk 来取代

### grep

cut 是将一行信息中，取出某部分我们想要的数据，而 grep 则是分析一堆信息，若一行当中有匹配的数据，则将这一行数据拿出来

```bash
grep [-acinv] [--color=auto] '搜索的字符串' filename
```

选项与参数：

- a：将 binary 文件以 text 文件的方式搜索数据
- c：计算找到「搜索字符」的次数
- i：忽略大小写
- n：输出行号
- v：反向选择，显示出没有搜索字符串的那一行数据
- `--color`：可以将找到的关键词部分加上颜色显示

```bash
# 范例 1：将 last 中，有出现 root 的那一行找出来
[mrcode@study ~]$ last | grep 'root'
root     tty3                          Sun Oct  6 23:16 - crash  (22:40)    
root     tty4                          Fri Oct  4 22:48 - 22:48  (00:00)  
# 会发现 root 被高亮颜色了，我们时候 type 命令查看，发现被自动加上了 color 参数
[mrcode@study ~]$ type grep
grep is aliased to `grep --color=auto'

# 范例 2：与 范例 1 相反，不要 root 的数据
[mrcode@study ~]$ last | grep -v 'root'
mrcode   pts/1        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/0        192.168.0.105    Mon Dec  2 01:25   still logged in   
mrcode   pts/1        192.168.0.105    Mon Dec  2 00:21 - 01:12  (00:51) 
reboot   system boot  3.10.0-1062.el7. Fri Oct  4 18:47 - 03:43  (08:56)

# 范例 3：在 last 的输出信息中，只要有 root 就取出，并且只取第一栏
# 结合 cut 命令取出第一栏
[mrcode@study ~]$ last | grep 'root' | cut -d ' ' -f 1
root
root

# 范例 4：取出 /etc/man_db.conf 内涵 MANPATH 的那几行
[mrcode@study ~]$ grep 'MANPATH' /etc/man_db.conf 
# MANDATORY_MANPATH                     manpath_element
# MANPATH_MAP           path_element    manpath_element

```

grep 支持的语法很多，用在正规表示法里，能够处理的数据太多。但是这里先不了解正规表示法，下一章再来讲解

这里只需要了解下，grep 可以解析一行文字，取得关键词，若改行有存在关键词，就会整行取出来

## 排序命令：sort、wc、uniq

